<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Hello World</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background-color: Canvas;
        color: CanvasText;
      }
      body {
        display: grid;
        place-items: center;
        min-height: 100vh;
        margin: 0;
      }
      h1 {
        font-size: clamp(2.5rem, 5vw, 4rem);
        font-weight: 700;
      }
    </style>
  </head>
  <body>
    <h1>Hello World</h1>
    <p id="status" role="status" aria-live="polite"></p>
    <script>
      const statusEl = document.getElementById("status");
      const setStatus = (message, isError = false) => {
        if (!statusEl) return;
        statusEl.textContent = message;
        statusEl.style.color = isError ? "crimson" : "";
      };

      const setError = (message) => {
        console.error(message);
        setStatus(message, true);
      };

      const speak = () => {
        const utterance = new SpeechSynthesisUtterance("Hello World");
        const voices = window.speechSynthesis.getVoices();
        if (voices.length) {
          utterance.voice = voices.find((voice) => voice.default) || voices[0];
        }
        window.speechSynthesis.cancel();
        try {
          window.speechSynthesis.speak(utterance);
          setStatus("Speech playback started.");
          return true;
        } catch (error) {
          setError(`Unable to start speech: ${error}`);
          return false;
        }
      };

      const trySpeakWhenVoicesReady = () => {
        if (!window.speechSynthesis.getVoices().length) {
          return false;
        }

        return speak();
      };

      const scheduleVoicePolling = () => {
        const pollInterval = 250;
        const pollTimeout = 5000;
        let elapsed = 0;

        const poll = () => {
          elapsed += pollInterval;
          if (trySpeakWhenVoicesReady()) {
            clearInterval(intervalId);
            return;
          }

          if (elapsed >= pollTimeout) {
            clearInterval(intervalId);
            setError("Timed out waiting for speech synthesis voices.");
          }
        };

        const intervalId = setInterval(poll, pollInterval);
        poll();
      };

      const handleVoicesChanged = () => {
        window.speechSynthesis.removeEventListener(
          "voiceschanged",
          handleVoicesChanged
        );
        if (!speak()) {
          setError("Speech synthesis failed after voices changed event.");
        }
      };

      document.addEventListener("DOMContentLoaded", () => {
        if (!("speechSynthesis" in window)) {
          setError("Speech synthesis is not supported in this browser.");
          return;
        }

        setStatus("Waiting for speech synthesis voices...");
        if (!trySpeakWhenVoicesReady()) {
          window.speechSynthesis.addEventListener(
            "voiceschanged",
            handleVoicesChanged
          );
          scheduleVoicePolling();
          setStatus("Waiting for voices to load...");
        }
      });
    </script>
  </body>
</html>
